#include "freertos/FreeRTOS.h"
#include <freertos/task.h>
#include "esp_wifi.h"
#include "esp_system.h"
#include "esp_event.h"
#include "esp_event_loop.h"
#include "nvs_flash.h"
#include "driver/gpio.h"
#include <driver/spi_master.h>
#include <esp_log.h>

#include "driver/gpio.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"

#include "main.h"
#include "msg_type.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "sd_card.h"
#include "temp_bme280.h"

#define TAG "MAIN"

extern void tsk_coord_save(void *pvParameters);
extern void gps_clock_task(void *pvParameters);
extern void tsk_disp_temp(void *pvParameters);
extern void task_disp_gps(void *pvParameters);
extern void task_disp_speed(void *pvParameters);
extern void task_disp_timedate(void *pvParameters);
extern void tsk_sd_getcoordinate(void *pvParameters);
extern void task_disp_coordinate(void *pvParameters);

// On board LED for Blink is on GPIO 21
#define LCD_LIGHT 5 // LCD Back Light
#define BTN 19      // Button on front panel

// TODO: Functions define how to stop a certain display mode for preparing to start
// the next, or do other things, like make a gps coordinate snapshot.
// TODO: Stop diplaying temprature/Humidity
void stop_mode_temp(void) {
  ESP_LOGI(TAG, "stop_mode_temp");
  loopholder_bme280 = 0; // Here I stop temperature reading Task
  loopholder_display = 0;// Here I stop Display Task
}

// Stop displaying GPS detailed information
void stop_mode_gps_detail(void) {
  ESP_LOGI(TAG, "stop_mode_gps_detail");
  loopholder_display = 0;// Here I stop Display Task
}

// Stop displaying gps speed
void stop_mode_speed(void) {
  ESP_LOGI(TAG, "stop_mode_speed");
  loopholder_display = 0;
}

void stop_mode_timedate(void) {
  ESP_LOGI(TAG, "stop_mode_datetime");
  loopholder_display = 0;
}

void stop_mode_coordinate(void) {
  ESP_LOGI(TAG, "stop_mode_coordinate");
  // TODO: Should I Stop task that read the last two record from SD card?
  loopholder_display = 0;
}

// Start mode display temperature/Humidity
void start_mode_temp(void) {
  ESP_LOGI(TAG, "start_mode_temp");
  loopholder_bme280 = 1;
  loopholder_display = 1;
  xTaskCreate(&task_bme280_normal_mode, "bme280_normal_mode",  2048, &loopholder_bme280, 6, NULL);
  xTaskCreate(&tsk_disp_temp, "task_display_info", 8048, &loopholder_display, 5, NULL);
}

// Start mode display gps information
void start_mode_gps_detail(void) {
  ESP_LOGI(TAG, "start_mode_gps_detail");
  loopholder_display = 1;
  xTaskCreate(&task_disp_gps, "task_disp_gps", 8048, &loopholder_display, 5, NULL);
}

void start_mode_speed(void) {
  ESP_LOGI(TAG, "start_mode_speed");
  loopholder_display = 1;
  xTaskCreate(&task_disp_speed, "task_disp_speed", 8048, &loopholder_display, 5, NULL);
}

void start_mode_timedate(void) {
  ESP_LOGI(TAG, "start_mode_speed");
  loopholder_display = 1;
  xTaskCreate(&task_disp_timedate, "task_disp_timedate", 8048, &loopholder_display, 5, NULL);
}

void start_mode_coordinate(void) {
  ESP_LOGI(TAG, "start_mode_coordinate");
  loopholder_display = 1;
  // TODO: Then I should deallocated the notification message object in display task, after it got/display the correct result
  lastTwoCoordRecord = xQueueCreate( 1, sizeof(char) * SD2DISPLAY_BUF * 2 );
  xTaskCreate(&tsk_sd_getcoordinate, "tsk_sd_getcoordinate", 8048, NULL, 5, NULL);
  char buf [SD2DISPLAY_BUF * 2];
  if( xQueuePeek( lastTwoCoordRecord, buf, 5000/portTICK_PERIOD_MS) ){
    ESP_LOGE(TAG, "Wait for sd card deliver gps coordiante read result timeout, can't start display");
  }
  xTaskCreate(&task_disp_coordinate, "task_disp_coordiate", 8048, &loopholder_display, 5, NULL);
}

// Handling a GPS Coordinate snapshot event
void snapshot_handler(){
  snapshotFlag = true;
  (*stopCertainMode[dMode])(); // Stop right now task(s)
  if(xSemaphoreTake(taskEndedSemaphoreArr[dMode],
      3000/portTICK_RATE_MS) != pdTRUE)
  {
    ESP_LOGW(TAG, "Wait for other task finish there job timeout!");
  }
  // Trigger the SD Card task
  xTaskCreate(&tsk_coord_save, "tsk_coord_save",  4096, NULL, 6, NULL);
  if(xSemaphoreTake(sdTskEndedSemaphore, 3000/portTICK_RATE_MS) != pdTRUE)
  {
    ESP_LOGW(TAG, "Wait for sd card I/O task finish its job timeout!");
  }
  (*startCertainMode[dMode])(); // Restart the old task where we stopped
}

void mode_switch_handler(){
  ESP_LOGI(TAG, "dMode=%d", dMode);
  (*stopCertainMode[dMode])();
  if(xSemaphoreTake(taskEndedSemaphoreArr[dMode], 3000/portTICK_RATE_MS) != pdTRUE) {
    ESP_LOGW(TAG, "Wait for other task finish there job timeout!");
  }
  ESP_LOGI(TAG, "Finish Stopping");
  if(dMode == TOTALMODE-1) {
    dMode = 0;
  } else {
    dMode++;
  }
  (*startCertainMode[dMode])();
}

void app_main(void)
{
  i2c_master_init();
  loopholder_bme280 = 1;
  loopholder_display = 1;
  coordinateSaveSucceed = true;
  snapshotFlag = false;
  gps = pvPortMalloc(sizeof(gps_t)); // define this gps object
  // Tipp: xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
  xTaskCreate(&task_bme280_normal_mode, "bme280_normal_mode",  2048, &loopholder_bme280, 6, NULL);
  xTaskCreate(gps_clock_task, "task_gps", 4096, NULL, 5, NULL);
  xTaskCreate(&tsk_disp_temp, "tsk_disp_temp", 8048, &loopholder_display, 5, NULL);
  dMode = TEMPERATUREANDHUMDIDITY;

  gpio_pad_select_gpio(LCD_LIGHT);
  gpio_set_direction(LCD_LIGHT, GPIO_MODE_OUTPUT);
  gpio_set_level(LCD_LIGHT, 1);

  for(int i=0; i<TOTALMODE; i++) {
    taskEndedSemaphoreArr[i] = xSemaphoreCreateBinary();
  }
  sdTskEndedSemaphore = xSemaphoreCreateBinary();

  stopCertainMode[0] = &stop_mode_temp;
  stopCertainMode[1] = &stop_mode_gps_detail;
  stopCertainMode[2] = &stop_mode_speed;
  stopCertainMode[3] = &stop_mode_timedate;
  stopCertainMode[4] = &stop_mode_coordinate;

  startCertainMode[0] = &start_mode_temp;
  startCertainMode[1] = &start_mode_gps_detail;
  startCertainMode[2] = &start_mode_speed;
  startCertainMode[3] = &start_mode_timedate;
  startCertainMode[4] = &start_mode_coordinate;

  // TODO: Would it better, if we wanna pack this in "btn_task"?
  // Button read
  gpio_pad_select_gpio(BTN);
  gpio_set_direction(BTN, GPIO_MODE_INPUT);
  gpio_pad_select_gpio(LCD_LIGHT);
  gpio_set_direction(LCD_LIGHT, GPIO_MODE_OUTPUT);
  int btn_old = 0;
  int btn_now = 0;
  uint32_t btn_long_press_old = 0;
  // Flag marking if btn press a long press to preventing long press trigger a
  // short btn press event at the same time.
  int longPressFlag = false;
  while(1) {
    btn_now = gpio_get_level(BTN);
    if(btn_now != btn_old){
      if(btn_now == 1){ // btn pressed down
        ESP_LOGI(TAG, "BTN get pressed down.");
        btn_long_press_old = xTaskGetTickCount();
        longPressFlag = false;
      } else { // btn released
        ESP_LOGI(TAG, "BTN get released.");
        // When button get released in <1 second, do the gps coordinate snapshot
        if(abs(xTaskGetTickCount()-btn_long_press_old) < 1000/portTICK_PERIOD_MS
            && !longPressFlag)
        {
          ESP_LOGI(TAG, "Triggered a snapshot");
          snapshot_handler();
        }
      }
      btn_old = btn_now;
      btn_long_press_old = xTaskGetTickCount();
    }
    else if(btn_now == 1) { // Check if this is a long press btn event
      // When the button get released after more then 1 second, then go to the next display mode.
      if(abs(xTaskGetTickCount()-btn_long_press_old) > 1000/portTICK_PERIOD_MS){
        ESP_LOGI(TAG, "long btn press get triggered");
        mode_switch_handler();
        btn_long_press_old=xTaskGetTickCount(); // Update timer preparing trigger the next long btn press event
        longPressFlag = true;
      }
    }
    else {
//      ESP_LOGI(TAG, "Button stays unpressed.");
    }
    vTaskDelay(100 / portTICK_PERIOD_MS);
  }
  printf("the damme esp32's main reach end!\n");
}
